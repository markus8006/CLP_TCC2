================================================================================
Arquivo: changelog.json
Pasta: changelog.json
--------------------------------------------------------------------------------
[
  {
    "version": "0.0.2",
    "date": "2025-09-12",
    "changes": {
      "added": [
        "Separação de clps e demais dispositivos",
        "Funções de controle de clp, listar clps",
        "Iniciando mecanismos de tags, ainda não testado"
      ],
      "fixed" : [
        "Nomes dos clps salvos com . ao invés de _",
        "Erro ao entrar na pagina inicial do site"
      ]
    }
  },
  {
    "version": "0.0.1",
    "date": "2025-09-11",
    "changes": {
      "added": [
        "Inicializão de notas de versão",
        "Estrutura inicial de metadata.json",
        "Mapeamento de portas via nmap",
        "Atualização de portas em clps já salvos"
      ],
      "fixed" : [
        "Nomes dos clps salvos com . ao invés de _"
      ]
    }
  }
]



================================================================================
Arquivo: requeriments.txt
Pasta: requeriments.txt
--------------------------------------------------------------------------------
Flask
Flask-Login
Flask-SQLAlchemy
Flask-WTF
psutil
scapy
werkzeug
pymodbus
ipaddress
netaddr


================================================================================
Arquivo: run.py
Pasta: run.py
--------------------------------------------------------------------------------
# /run.py
from clp_app import create_app
from utils.discovery import run_full_discovery, save_discoveries_to_json
from utils.clp_manager import criar_dispositivo
import json
import time

app = create_app()

import threading

def discovery_background():
    save_discoveries_to_json(run_full_discovery(passive_timeout=10))
    with open("data/discovery_results.json", "r", encoding="utf-8") as f:
        dados = json.load(f)
        for dado in dados:
            criar_dispositivo(dado)

if __name__ == '__main__':
    threading.Thread(target=discovery_background, daemon=True).start()
    app.run(host='0.0.0.0', port=5000, debug=True)



================================================================================
Arquivo: TCC_Projeto.txt
Pasta: TCC_Projeto.txt
--------------------------------------------------------------------------------



================================================================================
Arquivo: teste.py
Pasta: teste.py
--------------------------------------------------------------------------------
import os

# Caminho raiz do seu projeto (substitua pelo caminho correto)
RAIZ_PROJETO = "C:\\Users\\guilh_43osqzc\\Desktop\\CLP_TCC2"

# Arquivo onde tudo será salvo
ARQUIVO_TCC = "TCC_Projeto.txt"

# Tipos de arquivos que você quer incluir no TCC
EXTENSOES = [".py", ".txt", ".md", ".json", ".html", ".js", ".css"]  # adicione outras se quiser

PASTAS_IGNORADAS = {".venv", "__pycache__"}

with open(ARQUIVO_TCC, "w", encoding="utf-8") as tcc:
    for pasta_atual, subpastas, arquivos in os.walk(RAIZ_PROJETO):
        # Remove pastas ignoradas do walk
        subpastas[:] = [d for d in subpastas if d not in PASTAS_IGNORADAS]
        
        for arquivo in arquivos:
            if any(arquivo.endswith(ext) for ext in EXTENSOES):
                caminho_completo = os.path.join(pasta_atual, arquivo)
                caminho_relativo = os.path.relpath(caminho_completo, RAIZ_PROJETO)
                
                tcc.write("="*80 + "\n")
                tcc.write(f"Arquivo: {arquivo}\n")
                tcc.write(f"Pasta: {caminho_relativo}\n")
                tcc.write("-"*80 + "\n")
                
                try:
                    with open(caminho_completo, "r", encoding="utf-8") as f:
                        conteudo = f.read()
                        tcc.write(conteudo + "\n")
                except Exception as e:
                    tcc.write(f"[ERRO AO LER O ARQUIVO: {e}]\n")
                
                tcc.write("\n\n")

print(f"TCC gerado com sucesso em '{ARQUIVO_TCC}'!")



================================================================================
Arquivo: routes.py
Pasta: clp_app\routes.py
--------------------------------------------------------------------------------
# /clp_app/routes.py
from flask import Blueprint, render_template, request
from flask_login import login_required
from utils import clp_manager


main = Blueprint('main', __name__)

clps_por_pagina = 21


def obter_clps_lista():
    return clp_manager.listar_clps()

@main.route('/', methods=['GET', 'POST'])
@login_required 
def index():
    """Página principal do Dashboard, protegida por login."""
    clps_lista = obter_clps_lista()
    search_term = ""
    tag_term = "" # <-- NOVO

    if request.method == 'POST':
        search_term = request.form.get("buscar_clp", "").lower()
        tag_term = request.form.get("buscar_tag", "").lower() # <-- NOVO

        if search_term:
            clps_lista = [
                clp for clp in clps_lista
                if search_term in clp.get('nome', '').lower()
            ]
        
        # <-- NOVO: Filtra por tag se um termo de tag for fornecido
        if tag_term:
            clps_lista = [
                clp for clp in clps_lista
                if any(tag_term in tag.lower() for tag in clp.get('tags', []))
            ]

    # ... (lógica de paginação continua a mesma)
    page = request.args.get('page', 1, type=int)
    if not page:
        page = 1
    inicio = (page - 1) * clps_por_pagina
    fim = inicio + clps_por_pagina
    clps_pagina = clps_lista[inicio:fim]
    total_paginas = (len(clps_lista) + clps_por_pagina - 1) // clps_por_pagina
    
    return render_template(
        'index.html',
        clps=clps_pagina,
        page=page,
        total_paginas=total_paginas,
        valor=clps_por_pagina,
        search_term=search_term,
        tag_term=tag_term # <-- NOVO
    )

@login_required
@main.route('/clp/<ip>')
def detalhes_clps(ip):
    """Página de detalhes para um CLP específico."""
    clp_dict = clp_manager.buscar_por_ip(ip)
    return render_template("detalhes.html", clp=clp_dict)


================================================================================
Arquivo: __init__.py
Pasta: clp_app\__init__.py
--------------------------------------------------------------------------------
# /clp_app/__init__.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager
import os
from utils.root import get_project_root # Usando sua função para compatibilidade com .exe

# Declara as extensões
db = SQLAlchemy()
login_manager = LoginManager()
# Aponta para a rota de login dentro do blueprint 'auth'
login_manager.login_view = 'auth.login' 
login_manager.login_message = "Por favor, faça o login para aceder a esta página."
login_manager.login_message_category = "info"

def create_app():
    app = Flask(__name__)
    
    # Configurações essenciais
    app.config['SECRET_KEY'] = os.urandom(24)
    PROJECT_ROOT = get_project_root()
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(PROJECT_ROOT, 'clp_app/db/app.db')
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    # Inicializa as extensões com a aplicação
    db.init_app(app)
    login_manager.init_app(app)

    # Importa o modelo de utilizador para ser usado no user_loader
    from .users_page.models import User

    # NOVO E ESSENCIAL: Define a função user_loader
    @login_manager.user_loader
    def load_user(user_id):
        """Carrega o utilizador da sessão a partir do user_id."""
        return User.query.get(int(user_id))

    with app.app_context():
        # Cria as tabelas do banco de dados (se não existirem)
        db.create_all()

        # --- REGISTO DOS BLUEPRINTS ---
        # Regista as rotas principais (dashboard, etc.)
        from .routes import main as main_blueprint
        app.register_blueprint(main_blueprint)

        # Regista as rotas de autenticação (login, logout, etc.)
        from .users_page.auth_routes import auth_bp as auth_blueprint
        app.register_blueprint(auth_blueprint)

        from .api.routes import clp_bp
        app.register_blueprint(clp_bp)
        
        # Futuramente, registe aqui as suas rotas de API
        # from .api.routes import clp_bp
        # app.register_blueprint(clp_bp)

    return app


================================================================================
Arquivo: routes.py
Pasta: clp_app\api\routes.py
--------------------------------------------------------------------------------
# clp_app/api/routes.py

from flask import Blueprint, jsonify, request, redirect, url_for
import logging
from threading import Thread

# Imports de utilidades
from utils import clp_manager
from utils import tags_manager  # NOVO: Importa o gerenciador de tags globais
# from clp_app.scanner.service import scanner_service
# from utils.log import caminho_coleta, caminho_app

def _run_in_thread(target, *args, **kwargs):
    t = Thread(target=target, args=args, kwargs=kwargs, daemon=True)
    t.start()
    return t

clp_bp = Blueprint("utils", __name__, url_prefix="/clp")


# --- ROTAS DE TAGS ATUALIZADAS ---

@clp_bp.route("/tags", methods=['POST'])
def add_global_tag():
    """Adiciona uma tag à lista global de tags."""
    data = request.get_json()
    new_tag = data.get('tag', '').strip()

    if not new_tag:
        return jsonify({"success": False, "message": "A tag não pode estar vazia"}), 400

    adicionada = tags_manager.adicionar_tag_global(new_tag)
    
    if adicionada:
        return jsonify({
            "success": True, 
            "message": "Tag adicionada com sucesso à lista global", 
            "tags": tags_manager.tags_globais
        })
    else:
        return jsonify({
            "success": True, # Sucesso mesmo que já exista, pois o estado final é o desejado
            "message": "Esta tag já existe na lista global", 
            "tags": tags_manager.tags_globais
        })

@clp_bp.route("/tags", methods=['GET'])
def get_all_tags():
    """Retorna a lista completa de tags globais salvas."""
    return jsonify({
        "success": True, 
        "tags": tags_manager.tags_globais
    })

@clp_bp.route("/<ip>/tags/assign", methods=['POST'])
def assign_tag_to_clp(ip):
    """Associa uma tag existente a um CLP específico."""
    clp_dict = clp_manager.buscar_por_ip(ip)
    if not clp_dict:
        return jsonify({"success": False, "message": "CLP não encontrado"}), 404

    data = request.get_json()
    tag_to_assign = data.get('tag', '').strip()

    if not tag_to_assign:
        return jsonify({"success": False, "message": "A tag para associar não pode estar vazia"}), 400

    # Garante que a lista de tags do CLP existe
    if 'tags' not in clp_dict:
        clp_dict['tags'] = []

    # Adiciona a tag ao CLP específico se ela ainda não existir
    if tag_to_assign not in clp_dict['tags']:
        clp_dict['tags'].append(tag_to_assign)
        clp_manager.salvar_clps() # Salva o arquivo clps.json com a tag associada
        return jsonify({"success": True, "message": "Tag associada com sucesso", "tags": clp_dict['tags']})
    else:
        return jsonify({"success": False, "message": "CLP já possui esta tag", "tags": clp_dict['tags']})
    

@clp_bp.route('/<ip>/tags/<tag>', methods=['DELETE'])
def unassign_tag_from_clp(ip, tag):
    """Desassocia uma tag de um CLP específico."""
    clp_dict = clp_manager.buscar_por_ip(ip)
    if not clp_dict:
        return jsonify({"success": False, "message": "CLP não encontrado"}), 404

    # Verifica se a lista de tags existe no CLP
    if 'tags' not in clp_dict or not isinstance(clp_dict['tags'], list):
        return jsonify({"success": False, "message": "Este CLP não possui tags para remover"}), 400

    # Tenta remover a tag da lista
    if tag in clp_dict['tags']:
        clp_dict['tags'].remove(tag)
        clp_manager.salvar_clps()  # Salva a alteração no clps.json
        return jsonify({
            "success": True, 
            "message": f"Tag '{tag}' removida com sucesso deste CLP",
            "tags": clp_dict['tags']  # Retorna a lista de tags atualizada
        })
    else:
        return jsonify({"success": False, "message": f"Tag '{tag}' não encontrada neste CLP"}), 404


# --- ROTAS ORIGINAIS DO CLP (mantidas como estavam) ---

@clp_bp.route("/<ip>/connect", methods=["POST"])
def clp_connect(ip):
    clp_dict = clp_manager.buscar_por_ip(ip)
    if not clp_dict:
        return jsonify({"ok": False, "error": "CLP não encontrado"}), 404

    data = request.json or {}
    porta_selecionada = data.get("port")

    def job():
        clp_manager.adicionar_log(clp_dict, f"Iniciando tentativa de conexão na porta {porta_selecionada}...")
        try:
            clp_manager.conectar(clp_dict, port=porta_selecionada)
            clp_manager.adicionar_log(clp_dict, f"Estado após tentar conectar: {clp_dict.get('conectado')}")
            clp_manager.salvar_clps()
        except Exception as e:
            clp_manager.adicionar_log(clp_dict, f"Erro durante conectar: {e}")
            clp_manager.salvar_clps()

    _run_in_thread(job)
    return jsonify({"ok": True, "messageCLP": "Conexão iniciada em background"})

@clp_bp.route("/<ip>/disconnect", methods=["POST"])
def clp_disconnect(ip):
    clp_dict = clp_manager.buscar_por_ip(ip)
    if not clp_dict:
        return jsonify({"ok": False, "error": "CLP não encontrado"}), 404
    try:
        clp_manager.desconectar(clp_dict)
        clp_manager.salvar_clps()
        status_info = clp_manager.get_info(clp_dict)["status"]
        return jsonify({"ok": True, "message": "Desconectado", "status": status_info})
    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 500


@clp_bp.route("/<ip>/info", methods=["GET"])
def clp_info(ip):
    clp_dict = clp_manager.buscar_por_ip(ip)
    if not clp_dict:
        return jsonify({"ok": False, "error": "CLP não encontrado"}), 404
    return jsonify({"ok": True, "clp": clp_manager.get_info(clp_dict)})


@clp_bp.route("/<ip>/add_port", methods=["POST"])
def clp_add_port(ip):
    clp_dict = clp_manager.buscar_por_ip(ip)
    if not clp_dict:
        return jsonify({"ok": False, "error": "CLP não encontrado"}), 404

    data = request.json or {}
    porta = data.get("porta")
    if porta is None:
        return jsonify({"ok": False, "error": "porta obrigatória"}), 400

    try:
        clp_manager.adicionar_porta(clp_dict, int(porta))
        clp_manager.salvar_clps()
        return jsonify({"ok": True, "message": "Porta adicionada", "portas": clp_dict["PORTAS"]})
    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 500


@clp_bp.route("/<ip>/read_register", methods=["POST"])
def clp_read_register(ip):
    clp_dict = clp_manager.buscar_por_ip(ip)
    # Obtém o cliente de conexão a partir do módulo de funções
    client = clp_manager.get_client(ip)

    if not clp_dict or not client or not client.is_socket_open():
        return jsonify({"ok": False, "error": "CLP não conectado"}), 400

    data = request.json
    address = data.get("address")
    if address is None:
        return jsonify({"ok": False, "error": "Endereço é obrigatório"}), 400

    try:
        address = int(address)
        # unit=1 é o ID do escravo Modbus, padrão para muitas aplicações
        result = client.read_holding_registers(address, 1, unit=1)

        if result.isError():
            return jsonify({"ok": False, "error": "Erro Modbus ao ler registrador"})

        value = result.registers[0]
        return jsonify({"ok": True, "address": address, "value": value})

    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 500
        

# @clp_bp.route("/limpar_coleta_ip", methods=['POST'])
# def limpar_coleta_ip():
#     with open(caminho_coleta, "w", encoding="UTF-8"):
#         pass

    
#     return redirect(url_for("coleta_de_ips"))


# @clp_bp.route("/limpar_logs", methods=['POST'])
# def limpar_logs():
#     with open(caminho_app, "w", encoding="UTF-8"):
#         pass

    
    return redirect(url_for("logs_geral"))


@clp_bp.route('/rename', methods=['POST'])
def rename_clp():
    """Endpoint da API para renomear um CLP."""
    data = request.get_json()
    if not data or not data.get('ip') or not data.get('novo_nome'):
        return jsonify({'success': False, 'message': 'IP e novo nome são obrigatórios.'}), 400

    ip = data['ip']
    novo_nome = data['novo_nome'].strip()

    try:
        clp_alvo = clp_manager.buscar_por_ip(ip)
        if clp_alvo:
            clp_alvo['nome'] = novo_nome
            clp_manager.salvar_clps()
            return jsonify({'success': True, 'message': 'Nome atualizado com sucesso!'})
        else:
            return jsonify({'success': False, 'message': 'CLP não encontrado.'}), 404
    except Exception as e:
        logging.exception("Erro ao renomear CLP")
        return jsonify({'success': False, 'message': 'Erro interno no servidor.'}), 500


# --- Rotas do Scanner (não precisam de grandes mudanças) ---
# @clp_bp.route('/scanner/status', methods=['GET'])
# def get_scanner_status():
#     return jsonify({'status': scanner_service.get_status()})

# @clp_bp.route('/scanner/start', methods=['POST'])
# def start_scanner():
#     success = scanner_service.start()
#     return jsonify({'ok': success, 'status': scanner_service.get_status()})

# @clp_bp.route('/scanner/stop', methods=['POST'])
# def stop_scanner():
#     success = scanner_service.stop()
#     return jsonify({'ok': success, 'status': scanner_service.get_status()})

# NOTA: A rota 'baixar_codigo' foi removida pois dependia da subclasse CLPGen,
# que foi eliminada na refatoração. Ela pode ser recriada como uma função em
# 'clp_manager.py' se a funcionalidade for necessária.


================================================================================
Arquivo: __init__.py
Pasta: clp_app\api\__init__.py
--------------------------------------------------------------------------------



================================================================================
Arquivo: __init__.py
Pasta: clp_app\scanner\__init__.py
--------------------------------------------------------------------------------



================================================================================
Arquivo: detalhes.js
Pasta: clp_app\static\scripts\detalhes.js
--------------------------------------------------------------------------------
// Funções auxiliares globais
function showActionMsg(text, timeout = 4000) {
    const el = document.getElementById('mensagem');
    if (el) {
        el.textContent = text;
        if (timeout) setTimeout(() => el.textContent = '', timeout);
    }
}

function showClpMsg(text, timeout = 4000) {
    const el = document.getElementById('mensagemCLP');
    if (el) {
        el.textContent = text;
        if (timeout) setTimeout(() => el.textContent = '', timeout);
    }
}

async function fetchJson(url, opts) {
    try {
        const resp = await fetch(url, opts);
        if (!resp.ok) {
            return { ok: false, error: `HTTP error! status: ${resp.status}` };
        }
        return await resp.json();
    } catch (err) {
        return { ok: false, error: err.toString() };
    }
}


// --- CORREÇÃO: Bloco Único de Execução ---
document.addEventListener('DOMContentLoaded', () => {

    // --- Parte 1: Lógica de Conexão e Atualização ---
    const ip = document.getElementById('clpIp')?.textContent;
    if (!ip) {
        console.error("Não foi possível encontrar o IP do CLP na página.");
        return;
    }
    
    const btnConnect = document.getElementById('btnConnect');
    const btnDisconnect = document.getElementById('btnDisconnect');
    const btnReadRegister = document.getElementById('btnReadRegister');
    const logContainer = document.getElementById('logContainer');

    // Função para atualizar informações da página
    async function atualizarInfo(ip) {
        const res = await fetchJson(`/clp/${ip}/info`);
        if (!res.ok) return;

        const clp = res.clp;
        const statusEl = document.getElementById('statusText');
        const connectContainer = document.getElementById('connect-container');
        const disconnectContainer = document.getElementById('disconnect-container');

        // Verificação para garantir que os elementos existem antes de usá-los
        if (!statusEl || !connectContainer || !disconnectContainer) {
            console.error("Elementos de status ou botões não encontrados no HTML.");
            return;
        }
        
        statusEl.textContent = 'Status: ' + clp.status;
        statusEl.className = clp.status === 'Online' ? 'status_online' : 'status_offline';

        if (clp.status === 'Online') {
            connectContainer.style.display = 'none';
            disconnectContainer.style.display = 'inline-block';
        } else {
            connectContainer.style.display = 'inline-block';
            disconnectContainer.style.display = 'none';
        }

        if (logContainer && clp.logs) {
            logContainer.innerHTML = '';
            clp.logs.slice().reverse().forEach(logLine => {
                const logEntry = document.createElement('div');
                logEntry.textContent = logLine;
                logContainer.appendChild(logEntry);
            });
        }
    }
    
    // Listeners dos botões de conexão/desconexão
    if (btnConnect) {
        btnConnect.addEventListener('click', async () => {
            const selectedPort = document.getElementById('portSelect').value;
            showClpMsg(`Iniciando conexão na porta ${selectedPort}...`);
            await fetchJson(`/clp/${ip}/connect`, {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ port: Number(selectedPort) })
            });
            // A atualização automática vai pegar o novo status
        });
    }

    if (btnDisconnect) {
        btnDisconnect.addEventListener('click', async () => {
            showClpMsg('Desconectando...');
            await fetchJson(`/clp/${ip}/disconnect`, { method: 'POST' });
            atualizarInfo(ip); // Força uma atualização imediata
        });
    }

    // Listener do botão de ler registrador
    if (btnReadRegister) {
        btnReadRegister.addEventListener('click', async () => {
            const address = document.getElementById('inputAddress').value;
            const resultDiv = document.getElementById('readResult');
            if (!address) {
                resultDiv.innerHTML = `<span style="color: red;">Por favor, insira um endereço.</span>`;
                return;
            }
            showActionMsg(`Lendo endereço ${address}...`);
            const res = await fetchJson(`/clp/${ip}/read_register`, {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ address: Number(address) })
            });
            if (res.ok) {
                resultDiv.innerHTML = `Endereço <strong>${res.address}</strong> = <strong>${res.value}</strong>`;
                showActionMsg('Leitura concluída com sucesso!');
            } else {
                resultDiv.innerHTML = `<span style="color: red;">Erro: ${res.error}</span>`;
                showActionMsg(`Falha na leitura do endereço ${address}.`);
            }
        });
    }

    // Inicia a atualização periódica e chama uma vez no início
    setInterval(() => atualizarInfo(ip), 5000);
    atualizarInfo(ip);


    // --- Parte 2: Lógica para Edição do Nome do CLP ---
    const viewMode = document.getElementById('viewMode');
    const editMode = document.getElementById('editMode');
    const editNameBtn = document.getElementById('editNameBtn');
    const saveNameBtn = document.getElementById('saveNameBtn');
    const cancelNameBtn = document.getElementById('cancelNameBtn');
    const clpNameSpan = document.getElementById('clpName');
    const inputClpName = document.getElementById('inputClpName');
    const clpIpSpan = document.getElementById('clpIp');

    const enterEditMode = () => {
        if(viewMode && editMode && inputClpName && clpNameSpan) {
            viewMode.style.display = 'none';
            editMode.style.display = 'flex';
            inputClpName.value = clpNameSpan.textContent;
            inputClpName.focus();
        }
    };

    const exitEditMode = () => {
        if(viewMode && editMode) {
            viewMode.style.display = 'flex';
            editMode.style.display = 'none';
        }
    };

    const saveNewName = () => {
        const novoNome = inputClpName.value.trim();
        const clpIp = clpIpSpan.textContent;

        if (!novoNome || novoNome === clpNameSpan.textContent) {
            exitEditMode();
            return;
        }

        fetch('/clp/rename', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ip: clpIp, novo_nome: novoNome }),
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                clpNameSpan.textContent = novoNome;
            } else {
                alert('Erro ao atualizar o nome: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Erro na requisição:', error);
            alert('Ocorreu um erro de comunicação com o servidor.');
        })
        .finally(() => {
            exitEditMode();
        });
    };

    if (editNameBtn) editNameBtn.addEventListener('click', enterEditMode);
    if (saveNameBtn) saveNameBtn.addEventListener('click', saveNewName);
    if (cancelNameBtn) cancelNameBtn.addEventListener('click', exitEditMode);
});


================================================================================
Arquivo: graficos.js
Pasta: clp_app\static\scripts\graficos.js
--------------------------------------------------------------------------------
document.addEventListener('DOMContentLoaded', () => {
    const ctxCpu = document.getElementById('graficoCpu').getContext('2d');
    const graficoCpu = new Chart(ctxCpu, {
        type: 'line',
        data: {
            labels: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun'],
            datasets: [{
                label: 'Uso de CPU (%)',
                data: [20, 35, 40, 30, 50, 45],
                borderColor: '#00cfff',
                backgroundColor: 'rgba(0, 207, 255, 0.2)',
                fill: true,
                tension: 0.3
            }]
        },
        options: { responsive: true, maintainAspectRatio: false }
    });
    ctxCpu.canvas.classList.add('line-chart');

    const ctxMem = document.getElementById('graficoMemoria').getContext('2d');
    const graficoMemoria = new Chart(ctxMem, {
        type: 'doughnut',
        data: {
            labels: ['Usada', 'Livre'],
            datasets: [{ data: [65, 35], backgroundColor: ['#00cfff', '#222'], borderWidth: 2 }]
        },
        options: { responsive: true, maintainAspectRatio: false, cutout: '70%' }
    });
    ctxMem.canvas.classList.add('doughnut-chart');

    // Rede e Disco
    const ctxRede = document.getElementById('graficoRede').getContext('2d');
    const graficoRede = new Chart(ctxRede, { /* seu dataset */ });
    ctxRede.canvas.classList.add('line-chart');

    const ctxDisco = document.getElementById('graficoDisco').getContext('2d');
    const graficoDisco = new Chart(ctxDisco, { /* seu dataset */ });
    ctxDisco.canvas.classList.add('line-chart');
});



================================================================================
Arquivo: sidebar.js
Pasta: clp_app\static\scripts\sidebar.js
--------------------------------------------------------------------------------
document.addEventListener('DOMContentLoaded', () => {
    const menuBtn = document.getElementById('menuBtn');
    const sidenav = document.getElementById('mySidenav');
    const mainContent = document.getElementById('main-content');

    if (menuBtn) {
        menuBtn.addEventListener('click', () => {
            sidenav.classList.toggle('sidenav-open');
            mainContent.classList.toggle('main-content-shifted');
        });
    }
});


================================================================================
Arquivo: base.css
Pasta: clp_app\static\styles\base.css
--------------------------------------------------------------------------------
/* --- Layout Geral e Reset Básico --- */
:root {
    --primary-color: #8400ff;
    --secondary-color: #cc00ff;
    --dark-bg: #0a0018;
    --text-color: whitesmoke;
}

body {
    margin: 0;
    font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
    color: var(--text-color);
    background: radial-gradient(circle at top left, var(--dark-bg) 0%, #090016 90%, #1b0030 100%);
    min-height: 100vh;
}

a {
    color: var(--secondary-color);
    text-decoration: none;
    transition: color 0.3s;
}

a:hover {
    color: var(--text-color);
}

h1, h2 {
    color: var(--secondary-color);
    text-shadow: 0 2px 8px rgba(8, 0, 20, 0.2);
    letter-spacing: 1px;
}

.main-content {
    padding: 20px;
    margin-left: 60px; /* Espaço para o menu fechado */
    transition: margin-left 0.3s;
}

/* --- Navegação / Sidebar --- */
#menuBtn {
    font-size: 24px;
    cursor: pointer;
    position: fixed;
    top: 15px;
    left: 15px;
    color: #6e0096;
    z-index: 1001; /* Maior que o sidenav */
    background: rgba(255, 255, 255, 0.1);
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.2s;
}

#menuBtn:hover {
    color: white;
    background: #6e0096;
    transform: scale(1.1);
}

.sidenav {
    height: 100%;
    width: 0; /* Começa fechado */
    position: fixed;
    z-index: 1000;
    top: 0;
    left: 0;
    background: linear-gradient(160deg, #111 40%, #6e0096 100%);
    overflow-x: hidden;
    transition: 0.3s;
    padding-top: 80px; /* Espaço para o botão não sobrepor */
}

.sidenav nav a {
    padding: 10px 24px;
    font-size: 20px;
    display: block;
}

/* Classe para ser controlada via JS */
.sidenav-open {
    width: 250px;
}
.main-content-shifted {
    margin-left: 250px;
}


================================================================================
Arquivo: coleta.css
Pasta: clp_app\static\styles\coleta.css
--------------------------------------------------------------------------------
@import url('base.css');

.container_clps h1, .container_clps h2 {
    margin-bottom: 10px;
}
.status_online {
    color: #00ff99;
}
.status_offline {
    color: #ff3b3b;
}

/* Container com scroll para os logs */
.logs-container {
    max-height: 70vh;
    width: 100%;
    overflow-y: auto; /* Cria a barra de rolagem */
    border: 1px solid #6e0096;
    border-radius: 5px;
}

.logs-container table {
    width: 100%;
    border-collapse: collapse;
}

.logs-container th, .logs-container td {
    padding: 10px;
    text-align: center;
    border-bottom: 1px solid #4d026a;
}

/* Cabeçalho da tabela fixo no topo */
.logs-container th {
    position: sticky;
    top: 0;
    background-color: #1e1e1e; 
}

/* Cores alternadas nas linhas para melhor legibilidade */
.logs-container tbody tr:nth-child(even) {
    background-color: #2c2c2c;
}

.limpar_logs_ips {
    position: relative;
    top: -5px;
    background-color: #0d0081;
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    cursor: pointer;
    transition: 0.3s;
}

.limpar_logs_ips:hover {
    background-color: #1b00a3;
    transform: translateY(-2px);
}

.limpar_registros_ips {
    position: relative;
    top: -5px;
    background-color: #0d0081;
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    cursor: pointer;
    transition: 0.3s;
}

.limpar_registros_ips:hover {
    background-color: #1b00a3;
    transform: translateY(-2px);
}


================================================================================
Arquivo: detalhes.css
Pasta: clp_app\static\styles\detalhes.css
--------------------------------------------------------------------------------
@import url('base.css');

/* --- Status CLP --- */
.status_clp {
    margin-top: 20px;
    font-size: 20px;
    font-weight: bold;
    letter-spacing: 1px;
}
.status_online {
    color: #00ff99;
}
.status_offline {
    color: #ff3b3b;
}

/* --- Informações do CLP --- */
.informacao_clp {
    margin-top: 30px;
    background: rgba(255,255,255,0.05);
    border-radius: 14px;
    padding: 18px;
    box-shadow: 0 2px 12px rgba(20,1,44,0.7);
}
.informacao_clp h2 {
    margin-bottom: 10px;
    color: #a200ff;
}

/* --- Gráficos --- */
.graficos {
    margin-top: 30px;
}

.linha-graficos {
    display: flex;
    flex-wrap: wrap;
    gap: 24px;
    justify-content: center;
    align-items: stretch;
    margin-bottom: 20px;
}

.grafico-container {
    flex: 1 1 320px;
    max-width: auto;
    min-width: auto;
    background: rgba(255,255,255,0.05);
    border-radius: 14px;
    padding: 18px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    box-shadow: 0 2px 12px rgba(20,1,44,0.7);
    transition: box-shadow 0.2s;
}

.grafico-container canvas {
    width: 100% !important;
    max-width: auto;
    height: 260px !important;
}

@media (max-width: 900px) {
    .linha-graficos {
        flex-direction: column;
        gap: 18px;
    }
    .grafico-container {
        max-width: 100%;
        min-width: 0;
    }
}

/* static/styles/detalhes.css */

.info-item-editavel {
    display: flex;
    align-items: center;
    gap: 10px;
}

#viewMode, #editMode {
    display: flex;
    align-items: center;
    gap: 8px;
}

.btn-edit {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0 5px;
}

.btn-acao {
    background-color: #0d0081;
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    cursor: pointer;
    transition: 0.3s;
}

.btn-acao:hover {
    background-color: #1b00a3;
    transform: translateY(-2px);
}

.input-form {
    background-color: rgba(71, 0, 202, 0.5);
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    transition: 0.3s;
}

.input-form {
    background-color: #0d0081;
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    cursor: pointer;
    transition: 0.3s;
}

.input-form:hover {
    background-color: #1b00a3;
    transform: translateY(-2px);
}

.form-input {
    background-color: rgba(71, 0, 202, 0.5);
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    transition: 0.3s;
}

.form-input {
    background-color: #0d0081;
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    cursor: pointer;
    transition: 0.3s;
}

.form-input:hover {
    background-color: #1b00a3;
    transform: translateY(-2px);
}

.btn {
    background-color: #0d0081;
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    cursor: pointer;
    transition: 0.3s;
}


================================================================================
Arquivo: index.css
Pasta: clp_app\static\styles\index.css
--------------------------------------------------------------------------------
/* --- Formulário de Filtro --- */
.filter-form {
    margin-bottom: 30px;
}

.form__input {
    background-color: rgba(71, 0, 202, 0.5);
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    transition: 0.3s;
}

.form__button {
    background-color: #0d0081;
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    cursor: pointer;
    transition: 0.3s;
}

.form__button:hover {
    background-color: #1b00a3;
    transform: translateY(-2px);
}

/* --- Grid de CLPs --- */
.clp-grid {
    display: grid;
    /* Cria colunas que se ajustam: no mínimo 250px, no máximo 1 fração do espaço */
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 24px;
    padding-bottom: 30px;
}

/* --- Card CLP (Totalmente refeito com Flexbox) --- */
.clp-card {
    background-color: var(--primary-color);
    border-radius: 18px;
    box-shadow: 0 6px 24px rgba(68, 0, 107, 0.7);
    transition: transform 0.3s, box-shadow 0.3s;
}

.clp-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 12px 36px rgba(29, 2, 51, 0.9);
}

.clp-card a {
    display: flex; /* LAYOUT FLEXBOX: Robusto e responsivo */
    align-items: center; /* Alinha verticalmente */
    padding: 20px;
    gap: 20px; /* Espaço entre a imagem e o texto */
    color: var(--text-color);
}

.clp-card__image {
    width: 70px;  /* Tamanho fixo para a imagem */
    height: 70px;
    flex-shrink: 0; /* Impede que a imagem encolha */
}

.clp-card__ip {
    font-size: 0.9rem;
    font-weight: bold;
    word-break: break-all; /* Garante que IPs longos não quebrem o layout */
    margin-top: 0;
}

.clp-card__nome {
    font-size: 1.1rem;
    font-weight: bold;
    word-break: break-all;
     
}
/* --- Paginação --- */
.pagination {
    text-align: center;
    padding: 20px 0;
    font-size: 1.1rem;
}

.pagination a {
    margin: 0 15px;
}

/* --- Responsividade para Telas Pequenas --- */
@media (max-width: 768px) {
    .main-content {
        margin-left: 0; /* Remove a margem em telas pequenas */
    }

    .clp-grid {
        /* Uma coluna em telas pequenas */
        grid-template-columns: 1fr;
    }
    
    .filter-form {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
}


================================================================================
Arquivo: logs.css
Pasta: clp_app\static\styles\logs.css
--------------------------------------------------------------------------------
/* Importa estilos de um arquivo base, se existir. */
@import url('base.css');


/* Container com scroll para os logs */
.logs-container {
    max-height: 70vh;
    width: 100%;
    overflow-y: auto; /* Cria a barra de rolagem */
    border: 1px solid #6e0096;
    border-radius: 5px;
}

.logs-container table {
    width: 100%;
    border-collapse: collapse;
}

.logs-container th, .logs-container td {
    padding: 10px;
    text-align: center;
    border-bottom: 1px solid #4d026a;
}

/* Cabeçalho da tabela fixo no topo */
.logs-container th {
    position: sticky;
    top: 0;
    background-color: #1e1e1e; 
}

/* Cores alternadas nas linhas para melhor legibilidade */
.logs-container tbody tr:nth-child(even) {
    background-color: #2c2c2c;
}

.limpar_logs_clps {
    position: relative;
    top: -5px;
    background-color: #0d0081;
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    cursor: pointer;
    transition: 0.3s;
}

.limpar_logs_clps:hover {
    background-color: #1b00a3;
    transform: translateY(-2px);
}

.limpar_registros_clps {
    position: relative;
    top: -5px;
    background-color: #0d0081;
    color: white;
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid #6e0096;
    cursor: pointer;
    transition: 0.3s;
}

.limpar_registros_clps:hover {
    background-color: #1b00a3;
    transform: translateY(-2px);
}


================================================================================
Arquivo: base.html
Pasta: clp_app\templates\base.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Minha Aplicação{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/base.css') }}">
    {% block css %}{% endblock %}
</head>
<body>

    <button id="menuBtn">☰</button>
    <div id="mySidenav" class="sidenav">
        <nav>
            <a href="/">Home</a>
            <a href="/coletaIps">Coleta IPs</a>
            <a href="#">Contato</a>
            <a href="/logs">Logs</a>
        </nav>
    </div>

    <main id="main-content" class="main-content">
        {% block content %}{% endblock %}
    </main>

    <script src="{{ url_for('static', filename='scripts/sidebar.js') }}"></script>
    {% block scripts %} {% endblock %}

</body>
</html>


================================================================================
Arquivo: detalhes.html
Pasta: clp_app\templates\detalhes.html
--------------------------------------------------------------------------------
{% extends "base.html" %}

{% block title %}Detalhes do CLP{% endblock %}

{% block css %}
<link rel="stylesheet" href="{{ url_for('static', filename='styles/detalhes.css') }}">
<style>
    .tag-list { list-style: none; padding: 0; display: flex; flex-wrap: wrap; gap: 8px; }
    .tag-item { background-color: #5a009d; color: white; padding: 4px 10px; border-radius: 15px; font-size: 0.9em; }
</style>
{% endblock %}

{% block content %}
<div class="status_clp">
    <span id="statusText" class="{{ 'status_online' if clp.status == 'Online' else 'status_offline' }}">
        Status: {{ clp.status }}
    </span>

    <div id="connect-container" style="display: {{ 'none' if clp.status == 'Online' else 'inline-block' }};" class="form-acao">
        <label for="portSelect">Porta:</label>
        <select id="portSelect" class="input-form">
            {% if clp.portas %}
                {% for porta in clp.portas %}
                    <option value="{{ porta }}">{{ porta }}</option>
                {% endfor %}
            {% else %}
                <option value="502">502 (Padrão)</option>
            {% endif %}
        </select>
        <button id="btnConnect" data-ip="{{ clp.ip }}" class="btn-acao">Conectar</button>
    </div>

    <div id="disconnect-container" style="display: {{ 'inline-block' if clp.status == 'Online' else 'none' }};">
        <button id="btnDisconnect" data-ip="{{ clp.ip }}" class="btn-acao">Desconectar</button>
    </div>

    <div id="mensagemCLP" role="status" style="margin-top:12px;color:var(--accent)"></div>
</div>

<div class="informacao_clp">
    <h2>Informações do CLP</h2>
    <ul>
        <li class="info-item-editavel">
            <strong>Nome:</strong>
            <div id="viewMode">
                <span id="clpName">{{ clp.nome }}</span>
                <button id="editNameBtn" class="btn-edit" title="Editar Nome">✏️</button>
            </div>
            <div id="editMode" style="display: none;">
                <input type="text" id="inputClpName" class="form-input" value="{{ clp.nome }}">
                <button id="saveNameBtn" class="btn">Salvar</button>
                <button id="cancelNameBtn" class="btn btn-secondary">Cancelar</button>
            </div>
        </li>
        <li><strong>Modelo:</strong> {{ clp.get('modelo', 'Desconhecido') }}</li>
        <li><strong>Fabricante:</strong> {{ clp.get('fabricante', 'Desconhecido') }}</li>
        <li><strong>ip:</strong> <span id="clpip">{{ clp.ip }}</span></li>
        
        <li><strong>Tags:</strong>
            <ul class="tag-list" id="tag-list-container">
                {% for tag in clp.tags %}
                    <li class="tag-item">{{ tag }}</li>
                {% else %}
                    <li>Nenhuma tag definida.</li>
                {% endfor %}
            </ul>
        </li>

        {% if clp.portas %}
            <li><strong>portas abertas:</strong>
                <span id="listaportas">
                {% for porta in clp.portas %}
                    <span class="porta_item">{{ porta }}{% if not loop.last %}, {% endif %}</span>
                {% endfor %}
                </span>
            </li>
        {% else %}
            <li><span class="porta_fechada">Não há portas abertas</span></li>
        {% endif %}
        <li><strong>Versão Firmware:</strong> {{ clp.get('firmware', 'N/A') }}</li>
        <li><strong>Última comunicação:</strong> {{ clp.data_registro }}</li>
    </ul> </div>

<div class="informacao_clp">
    <h2>Adicionar Tag</h2>
    <form id="formAddTag" onsubmit="return false;" class="form-acao">
        <input type="text" id="inputTag" placeholder="Nova tag" required class="input-form">
        <button id="btnAddTag" class="btn-acao">Adicionar</button>
    </form>
    <div id="tagMessage" style="margin-top: 10px;"></div>
</div>

<div class="informacao_clp">
    <h2>Leitor de Registrador Modbus</h2>
    <form id="formReadRegister" onsubmit="return false;" class="form-acao">
        <input type="number" id="inputAddress" placeholder="Endereço (ex: 0)" required class="input-form">
        <button id="btnReadRegister" class="btn-acao">Ler Registrador</button>
    </form>
    <div id="readResult" class="resultado-acao" style="margin-top: 10px;"></div>
</div>

<div id="mensagem" role="status" style="margin-top:12px;color:var(--accent)"></div>

<div class="graficos">
    <h2>Métricas do Dispositivo (Exemplo)</h2>
    <div class="linha-graficos">
        <div class="grafico-container">
            <h3>Uso de CPU</h3>
            <canvas id="graficoCpu"></canvas>
        </div>
        <div class="grafico-container">
            <h3>Uso de Memória</h3>
            <canvas id="graficoMemoria"></canvas>
        </div>
    </div>
    <div class="linha-graficos">
        <div class="grafico-container">
            <h3>Tráfego de Rede</h3>
            <canvas id="graficoRede"></canvas>
        </div>
        <div class="grafico-container">
            <h3>Uso de Disco</h3>
            <canvas id="graficoDisco"></canvas>
        </div>
    </div>
</div>

<div class="informacao_clp">
    <h2>Logs de Atividade</h2>
    <div id="logContainer" style="height: 200px; overflow-y: scroll; background-color: rgba(0,0,0,0.2); border-radius: 5px; padding: 10px; font-family: monospace;">
    </div>
</div>

{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="{{ url_for('static', filename='scripts/graficos.js') }}"></script>
<script src="{{ url_for('static', filename='scripts/detalhes.js') }}"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const btnAddTag = document.getElementById('btnAddTag');
    if (btnAddTag) {
        btnAddTag.addEventListener('click', async () => {
            const ip = document.getElementById('clpip').textContent;
            const inputTag = document.getElementById('inputTag');
            const newTag = inputTag.value.trim();
            const tagMessage = document.getElementById('tagMessage');

            if (!newTag) {
                tagMessage.textContent = 'Por favor, insira uma tag.';
                return;
            }

            const response = await fetch(`/clp/${ip}/tags`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ tag: newTag })
            });

            const data = await response.json();
            tagMessage.textContent = data.message;

            if (data.success) {
                const tagListContainer = document.getElementById('tag-list-container');
                tagListContainer.innerHTML = ''; 
                data.tags.forEach(tag => {
                    const li = document.createElement('li');
                    li.className = 'tag-item';
                    li.textContent = tag;
                    tagListContainer.appendChild(li);
                });
                inputTag.value = '';
            }
        });
    }
});
</script>
{% endblock %}


================================================================================
Arquivo: index.html
Pasta: clp_app\templates\index.html
--------------------------------------------------------------------------------
{% extends "base.html" %}

{% block title %}CLPs Detectados{% endblock %}

{% block css %}
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/index.css') }}">
{% endblock %}

{% block content %}
    <h1>CLPs Detectados</h1>

    
    <div class="filter-controls">
        <form class="search-form" method="POST" action="{{ url_for('main.index') }}">
            <input 
                class="form__input" 
                type="text" 
                name="buscar_clp" 
                placeholder="Procurar por nome..." 
                value="{{ search_term or '' }}">
            
            <input 
                class="form__input" 
                type="text" 
                name="buscar_tag" 
                placeholder="Procurar por tag..." 
                value="{{ tag_term or '' }}">

            <button class="form__button" type="submit">Buscar</button>
        </form>

        </div>

    {% if search_term %}
        <p>Exibindo resultados para: <strong>"{{ search_term }}"</strong></p>
    {% else %}
        <p>Exibindo {{ clps|length }} de {{ clps|length }} CLPs por página.</p>
    {% endif %}

    <div class="clp-grid">
        {% for clp in clps %}
            <article class="clp-card">
                <a href="/clp/{{ clp.ip }}" title="Descrição {{ clp.descricao }} | Portas: {{ clp.portas }}">
                <img class="clp-card__image" src="{{ url_for('static', filename='imgs/clp_imagem.png') }}" alt="Ícone de um CLP industrial">
                <div class="clp-card__details">
                    <p class="clp-card__nome">{{ clp.nome }}</p>
                    <p class="clp-card__ip">{{ clp.ip }}</p>
                </div>
                </a>
            </article>

        {% else %}
            <p>Nenhum CLP encontrado com esse nome.</p>
        {% endfor %}
    </div>

    <div class="pagination">
        {% if page > 1 %}
            <a href="/?page={{ page - 1 }}">« Anterior</a>
        {% endif %}

        <span>Página {{ page }} de {{ total_paginas }}</span>

        {% if page < total_paginas %}
            <a href="/?page={{ page + 1 }}">Próxima »</a>
        {% endif %}
    </div>
{% endblock %}


================================================================================
Arquivo: login.html
Pasta: clp_app\templates\users_page\login.html
--------------------------------------------------------------------------------
{% extends "users_page/users_base.html" %}

{% block title %}Login - Gerenciador de CLPs{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6 col-lg-4">
        <div class="card">
            <div class="card-body">
                <h2 class="card-title text-center mb-4">Login</h2>
                
                <form method="POST" action="{{ url_for('auth.login') }}" novalidate>
                    
                    {{ form.hidden_tag() }}

                    <div class="form-group">
                        {{ form.username.label(class="font-weight-bold") }}
                        {{ form.username(class="form-control", placeholder="Digite seu usuário") }}
                        
                        {% for error in form.username.errors %}
                            <span class="text-danger">{{ error }}</span>
                        {% endfor %}
                    </div>

                    <div class="form-group">
                        {{ form.password.label(class="font-weight-bold") }}
                        {{ form.password(class="form-control", placeholder="Digite sua senha") }}
                        
                        {% for error in form.password.errors %}
                            <span class="text-danger">{{ error }}</span>
                        {% endfor %}
                    </div>

                    {{ form.submit(class="btn btn-primary btn-block") }}
                </form>
            </div>
            <div class="card-footer text-center">
                <small>Não tem uma conta? <a href="{{ url_for('auth.register') }}">Registe-se</a></small>
            </div>
        </div>
    </div>
</div>
{% endblock %}


================================================================================
Arquivo: register.html
Pasta: clp_app\templates\users_page\register.html
--------------------------------------------------------------------------------
{% extends "users_page/users_base.html" %}

{% block title %}Registar - Gerenciador de CLPs{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6 col-lg-4">
        <div class="card">
            <div class="card-body">
                <h2 class="card-title text-center mb-4">Criar Conta</h2>
                
                <form method="POST" action="{{ url_for('auth.register') }}" novalidate>
                    
                    {{ form.hidden_tag() }}

                    <div class="form-group">
                        {{ form.username.label(class="font-weight-bold") }}
                        {{ form.username(class="form-control", placeholder="Escolha um nome de utilizador") }}
                        
                        {% for error in form.username.errors %}
                            <span class="text-danger small">{{ error }}</span>
                        {% endfor %}
                    </div>

                    <div class="form-group">
                        {{ form.password.label(class="font-weight-bold") }}
                        {{ form.password(class="form-control", placeholder="Crie uma senha") }}
                        
                        {% for error in form.password.errors %}
                            <span class="text-danger small">{{ error }}</span>
                        {% endfor %}
                    </div>

                    <div class="form-group">
                        {{ form.password2.label(class="font-weight-bold") }}
                        {{ form.password2(class="form-control", placeholder="Confirme a senha") }}
                        
                        {% for error in form.password2.errors %}
                            <span class="text-danger small">{{ error }}</span>
                        {% endfor %}
                    </div>

                    {{ form.submit(class="btn btn-success btn-block") }}
                </form>
            </div>
            <div class="card-footer text-center">
                <small>Já tem uma conta? <a href="{{ url_for('auth.login') }}">Faça o login</a></small>
            </div>
        </div>
    </div>
</div>
{% endblock %}


================================================================================
Arquivo: users_base.html
Pasta: clp_app\templates\users_page\users_base.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Gerenciador de CLPs{% endblock %}</title>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
    
    {% block css %}{% endblock %}
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="{{ url_for('main.index') }}">CLP Manager</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ml-auto">
                    {% if current_user.is_authenticated %}
                        <li class="nav-item">
                            <span class="navbar-text mr-3">
                                Olá, {{ current_user.username }}!
                            </span>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="{{ url_for('main.index') }}">Dashboard</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="{{ url_for('auth.logout') }}">Sair</a>
                        </li>
                    {% else %}
                        <li class="nav-item">
                            <a class="nav-link" href="{{ url_for('auth.login') }}">Login</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="{{ url_for('auth.register') }}">Registar</a>
                        </li>
                    {% endif %}
                </ul>
            </div>
        </div>
    </nav>

    <main class="container mt-4">
        {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            {% for category, message in messages %}
                <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                    {{ message }}
                    <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
            {% endfor %}
        {% endif %}
        {% endwith %}

        {% block content %}{% endblock %}
    </main>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>

    {% block scripts %}{% endblock %}
</body>
</html>


================================================================================
Arquivo: auth_routes.py
Pasta: clp_app\users_page\auth_routes.py
--------------------------------------------------------------------------------
# /clp_app/users/auth_routes.py
from flask import Blueprint, render_template, redirect, url_for, flash
from flask_login import login_user, logout_user, login_required, current_user
from .forms import LoginForm, RegistrationForm
from .models import User, UserRole
from .decorators import role_required
from .. import db  # Importa o 'db' do __init__.py da pasta clp_app

# Cria um Blueprint para as rotas de autenticação
auth_bp = Blueprint('auth', __name__)




@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))
    
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.check_password(form.password.data):
            flash('Utilizador ou senha inválidos.', 'danger')
            return redirect(url_for('auth.login'))
        
        login_user(user)
        # Redireciona para a página principal (que está no blueprint 'main')
        return redirect(url_for('main.index'))
    
    return render_template('users_page/login.html', form=form)

@auth_bp.route('/logout')
@login_required
def logout():
    logout_user()
    flash('Você foi desconectado.', 'info')
    return redirect(url_for('auth.login'))

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    # Por segurança, apenas o primeiro utilizador pode-se registar livremente.
    if User.query.count() > 0 and not current_user.is_authenticated:
        flash('O registo de novos utilizadores está desabilitado.', 'warning')
        return redirect(url_for('auth.login'))

    form = RegistrationForm()
    if form.validate_on_submit():
        # O primeiro utilizador registado será um ADMIN
        user = User(username=form.username.data, role=UserRole.ADMIN)
        user.set_password(form.password.data)
        db.session.add(user)
        db.session.commit()
        flash('Utilizador Administrador registado com sucesso! Por favor, faça o login.', 'success')
        return redirect(url_for('auth.login'))
        
    return render_template('users_page/register.html', form=form)


================================================================================
Arquivo: decorators.py
Pasta: clp_app\users_page\decorators.py
--------------------------------------------------------------------------------
from functools import wraps
from flask import abort
from flask_login import current_user



def role_required(role_name):
    """ Decorator que restringe o acesso a usuários com um papel específico.
    :param role_name: O nome do papel requerido (ex: 'admin' ou UserRole.ADMIN)."""

    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # Verifica se o usuário está autenticado

            if not current_user.is_authenticated:
                 return abort(401)
            

            if current_user.role != role_name:
                return abort(403)
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator


================================================================================
Arquivo: forms.py
Pasta: clp_app\users_page\forms.py
--------------------------------------------------------------------------------
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField
from wtforms.validators import DataRequired, EqualTo, ValidationError
from .models import User

class LoginForm(FlaskForm):
    username = StringField('Usuário', validators=[DataRequired()])
    password = PasswordField('Senha', validators=[DataRequired()])
    submit = SubmitField('Entrar')

class RegistrationForm(FlaskForm):
    username = StringField('Usuário', validators=[DataRequired()])
    password = PasswordField('Senha', validators=[DataRequired()])
    password2 = PasswordField(
        'Repetir Senha', validators=[DataRequired(), EqualTo('password', message='As senhas devem ser iguais.')])
    submit = SubmitField('Registrar')

    def validate_username(self, username):
        """Verifica se o nome de usuário já existe no banco de dados."""
        user = User.query.filter_by(username=username.data).first()
        if user is not None:
            raise ValidationError('Este nome de usuário já está em uso. Por favor, escolha outro.')


================================================================================
Arquivo: models.py
Pasta: clp_app\users_page\models.py
--------------------------------------------------------------------------------
# /clp_app/users/models.py
from flask_login import UserMixin
from .. import db  # O '..' significa importar da pasta pai (clp_app)
import enum
from werkzeug.security import generate_password_hash, check_password_hash

# Cria uma classe enum para os papéis (ótima ideia!)
class UserRole(enum.Enum):
    USER = 'user'
    MODERATOR = 'moderator'
    ADMIN = 'admin'

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)

    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(256))

   
    role = db.Column(db.Enum(UserRole), nullable=False, default=UserRole.USER)

    def set_password(self, password):
        """Cria um hash para a senha. (CORRIGIDO)"""

        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        """Verifica a senha fornecida."""
        return check_password_hash(self.password_hash, password)

    @property
    def is_admin(self):
        return self.role == UserRole.ADMIN
    
    @property
    def is_moderator(self):
        return self.role == UserRole.MODERATOR


    def __repr__(self):
        return f"<User {self.username}>"


================================================================================
Arquivo: __init__.py
Pasta: clp_app\users_page\__init__.py
--------------------------------------------------------------------------------



================================================================================
Arquivo: clps.json
Pasta: data\clps.json
--------------------------------------------------------------------------------
[
    {
        "ip": "192.168.0.10",
        "mac": "00:1A:2B:3C:4D:5E",
        "subnet": "255.255.255.0",
        "nome": "CLP_192.168.0.10",
        "tipo": "CLP",
        "grupo": "Produção",
        "metadata": {
            "fabricante": "Siemens AG",
            "modelo": "S7-1200",
            "versao_firmware": "V4.3",
            "data_instalacao": "2023-08-15",
            "responsavel": "Eng. Guilherme",
            "numero_serie": "SN123456789"
        },
        "tags": ["linha1", "esteira", "motor"],
        "status": "Offline",
        "portas": [502, 102],
        "data_registro": "2025-09-12 14:30:00",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como CLP, fabricante: Siemens AG",
                "data": "2025-09-12 14:30:00"
            }
        ]
    }
]



================================================================================
Arquivo: devices.json
Pasta: data\devices.json
--------------------------------------------------------------------------------
[
    {
        "ip": "192.168.18.1",
        "mac": "f0:25:8e:aa:2f:24",
        "subnet": "192.168.18.0/24",
        "nome": "Smartphone / Tablet / Web Device_192.168.18.1",
        "tipo": "Smartphone / Tablet / Web Device",
        "grupo": "Sem Grupo",
        "metadata": {
            "fabricante": "HUAWEI TECHNOLOGIES CO.,LTD",
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": null,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": [
            53,
            80
        ],
        "data_registro": "2025-09-12 14:25:32",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como Smartphone / Tablet / Web Device, fabricante: HUAWEI TECHNOLOGIES CO.,LTD",
                "data": "2025-09-12 14:25:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [53, 80]",
                "data": "2025-09-12 14:47:17"
            }
        ]
    },
    {
        "ip": "192.168.18.14",
        "mac": "6a:7c:e1:dd:67:6e",
        "subnet": "192.168.18.0/24",
        "nome": "Desconhecido_192.168.18.14",
        "tipo": "Desconhecido",
        "grupo": "Sem Grupo",
        "metadata": {
            "fabricante": "Desconhecido",
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": null,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": [],
        "data_registro": "2025-09-12 14:25:32",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como Desconhecido, fabricante: Desconhecido",
                "data": "2025-09-12 14:25:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: []",
                "data": "2025-09-12 14:47:17"
            }
        ]
    },
    {
        "ip": "192.168.18.15",
        "mac": "34:23:87:77:19:d2",
        "subnet": "192.168.18.0/24",
        "nome": "Desconhecido_192.168.18.15",
        "tipo": "Desconhecido",
        "grupo": "Sem Grupo",
        "metadata": {
            "fabricante": "Hon Hai Precision Ind. Co.,Ltd.",
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": null,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": [
            135,
            139,
            445
        ],
        "data_registro": "2025-09-12 14:25:32",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como Desconhecido, fabricante: Hon Hai Precision Ind. Co.,Ltd.",
                "data": "2025-09-12 14:25:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 14:47:17"
            }
        ]
    },
    {
        "ip": "192.168.18.43",
        "mac": "b6:57:b0:88:e4:4c",
        "subnet": "192.168.18.0/24",
        "nome": "Desconhecido_192.168.18.43",
        "tipo": "Desconhecido",
        "grupo": "Sem Grupo",
        "metadata": {
            "fabricante": "Desconhecido",
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": null,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": [],
        "data_registro": "2025-09-12 14:25:32",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como Desconhecido, fabricante: Desconhecido",
                "data": "2025-09-12 14:25:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: []",
                "data": "2025-09-12 14:47:17"
            }
        ]
    },
    {
        "ip": "192.168.18.197",
        "mac": "c8:12:0b:1a:b5:b0",
        "subnet": "192.168.18.0/24",
        "nome": "Desconhecido_192.168.18.197",
        "tipo": "Desconhecido",
        "grupo": "Sem Grupo",
        "metadata": {
            "fabricante": "Samsung Electronics Co.,Ltd",
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": null,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": [],
        "data_registro": "2025-09-12 14:25:32",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como Desconhecido, fabricante: Samsung Electronics Co.,Ltd",
                "data": "2025-09-12 14:25:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: []",
                "data": "2025-09-12 14:47:17"
            }
        ]
    },
    {
        "ip": "192.168.18.209",
        "mac": "c4:9d:ed:6e:09:db",
        "subnet": "192.168.18.0/24",
        "nome": "Desconhecido_192.168.18.209",
        "tipo": "Desconhecido",
        "grupo": "Sem Grupo",
        "metadata": {
            "fabricante": "Microsoft Corporation",
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": null,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": [],
        "data_registro": "2025-09-12 14:25:32",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como Desconhecido, fabricante: Microsoft Corporation",
                "data": "2025-09-12 14:25:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: []",
                "data": "2025-09-12 14:47:17"
            }
        ]
    },
    {
        "ip": "192.168.18.231",
        "mac": "1e:a6:f7:8c:a4:0e",
        "subnet": "192.168.18.0/24",
        "nome": "Servidor ou Dispositivo IoT_192.168.18.231",
        "tipo": "Servidor ou Dispositivo IoT",
        "grupo": "Sem Grupo",
        "metadata": {
            "fabricante": "Desconhecido",
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": null,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": [
            22,
            80
        ],
        "data_registro": "2025-09-12 14:25:32",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como Servidor ou Dispositivo IoT, fabricante: Desconhecido",
                "data": "2025-09-12 14:25:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [22, 80]",
                "data": "2025-09-12 14:47:17"
            }
        ]
    },
    {
        "ip": "192.168.18.233",
        "mac": "96:6a:9e:73:e5:84",
        "subnet": "192.168.18.0/24",
        "nome": "Desconhecido_192.168.18.233",
        "tipo": "Desconhecido",
        "grupo": "Sem Grupo",
        "metadata": {
            "fabricante": "Desconhecido",
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": null,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": [],
        "data_registro": "2025-09-12 14:25:32",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como Desconhecido, fabricante: Desconhecido",
                "data": "2025-09-12 14:25:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: []",
                "data": "2025-09-12 14:47:17"
            }
        ]
    },
    {
        "ip": "192.168.18.8",
        "mac": "34:23:87:77:19:d2",
        "subnet": "192.168.18.0/24",
        "nome": "Desconhecido_192.168.18.8",
        "tipo": "Desconhecido",
        "grupo": "Sem Grupo",
        "metadata": {
            "fabricante": "Hon Hai Precision Ind. Co.,Ltd.",
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": null,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": [
            135,
            139,
            445
        ],
        "data_registro": "2025-09-12 14:55:05",
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": "Dispositivo identificado como Desconhecido, fabricante: Hon Hai Precision Ind. Co.,Ltd.",
                "data": "2025-09-12 14:55:05"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 14:55:49"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 14:57:12"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 14:57:33"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 14:59:00"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 15:00:31"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 15:01:04"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 15:01:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 15:08:25"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 16:32:32"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 16:33:22"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 16:34:48"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 16:35:58"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 16:36:49"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 16:42:16"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 16:53:12"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 16:55:28"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 16:57:44"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 17:00:50"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 17:01:16"
            },
            {
                "acao": "Atualizacao",
                "detalhes": "Portas atualizadas: [135, 139, 445]",
                "data": "2025-09-12 17:06:59"
            }
        ]
    }
]


================================================================================
Arquivo: discovery_results.json
Pasta: data\discovery_results.json
--------------------------------------------------------------------------------
[
    {
        "ip": "192.168.18.8",
        "mac": "34:23:87:77:19:d2",
        "subnet": "192.168.18.0/24",
        "portas": [
            135,
            139,
            445
        ]
    }
]


================================================================================
Arquivo: clp_manager.py
Pasta: utils\clp_manager.py
--------------------------------------------------------------------------------
import json
import os
import logging
from datetime import datetime
from netaddr import EUI, NotRegisteredError
from utils.root import get_project_root
from typing import List, Dict, Any, Optional, Tuple
import tempfile
from pymodbus.client import ModbusTcpClient

# --- Configurações ---
PROJECT_ROOT = get_project_root()
CLPS_FILE = os.path.join(PROJECT_ROOT, "data/clps.json")        # arquivo original para CLPs
DEVICES_FILE = os.path.join(PROJECT_ROOT, "data/devices.json")  # arquivo separado para outros dispositivos

_active_clients = {}


# Garante que a pasta exista
os.makedirs(os.path.dirname(CLPS_FILE), exist_ok=True)


_clps = {}
try:
    with open(CLPS_FILE, "r", encoding="UTF-8") as f:
        _clps = json.load(f)
except FileNotFoundError:
    print(f"Error: The file at {CLPS_FILE} was not found.")
except json.JSONDecodeError:
    print(f"Error: The file at {CLPS_FILE} is not a valid JSON file.")



def buscar_todos():
    try:
        with open(CLPS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return {}
    

# --- Carregamento dos JSONs existentes ---
def _carregar_arquivo(path: str) -> List[Dict[str, Any]]:
    if not os.path.exists(path):
        return []
    try:
        with open(path, "r", encoding="utf-8") as f:
            content = f.read()
            return json.loads(content) if content.strip() else []
    except (json.JSONDecodeError, IOError) as e:
        logging.error(f"Erro ao carregar {path}: {e}")
        return []

_clps_data: List[Dict[str, Any]] = _carregar_arquivo(CLPS_FILE)
_others_data: List[Dict[str, Any]] = _carregar_arquivo(DEVICES_FILE)


# --- Funções de salvamento (escrita atômica) ---
def _salvar_arquivo(path: str, data: List[Dict[str, Any]]) -> None:
    try:
        dirpath = os.path.dirname(path)
        with tempfile.NamedTemporaryFile("w", encoding="utf-8", dir=dirpath, delete=False) as tf:
            json.dump(data, tf, indent=4, ensure_ascii=False)
            tempname = tf.name
        os.replace(tempname, path)
    except IOError as e:
        logging.error(f"Erro ao salvar {path}: {e}")

def salvar_clps() -> None:
    _salvar_arquivo(CLPS_FILE, _clps_data)

def salvar_others() -> None:
    _salvar_arquivo(DEVICES_FILE, _others_data)


# --- Funções de busca ---
def buscar_por_ip(ip_procurado: str) -> Optional[Dict[str, Any]]:
    """
    Busca por IP em ambos os arquivos.
    Retorna o dict encontrado ou None.
    """
    for clp in _clps_data:
        if clp.get("ip") == ip_procurado:
            return clp

    for dev in _others_data:
        if dev.get("ip") == ip_procurado:
            return dev

    return None


# --- Remover por referência (auxiliar para mover entre listas) ---
def _remover_por_ip_de_lista(ip: str, lista: List[Dict[str, Any]]) -> None:
    idx = next((i for i, e in enumerate(lista) if e.get("ip") == ip), None)
    if idx is not None:
        lista.pop(idx)


# --- Criação / Enriquecimento de dispositivo ---
def criar_dispositivo(dados: dict, grupo: str = "Sem Grupo") -> dict:
    ip = dados.get("ip")
    mac = dados.get("mac")
    subnet = dados.get("subnet", "Desconhecida")
    portas = dados.get("portas", []) or []

    if not ip:
        logging.warning("[WARN] criar_dispositivo chamado sem IP válido.")
        return {}

    # Verifica se já existe
    existente = buscar_por_ip(ip)
    if existente:
        logging.info(f"[INFO] Atualizando dispositivo existente: {ip}")
        # Mescla portas evitando duplicatas
        portas_existentes = set(existente.get("portas", []))
        portas_existentes.update(portas)
        existente["portas"] = sorted(list(portas_existentes))
        existente.setdefault("logs", []).append({
            "acao": "Atualizacao",
            "detalhes": f"Portas atualizadas: {portas}",
            "data": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        })
        # Decide onde salvar
        if existente.get("tipo") == "CLP":
            salvar_clps()
        else:
            salvar_others()
        return existente

    # Determina fabricante
    fabricante = "Desconhecido"
    if mac:
        try:
            fabricante = str(EUI(mac).oui.registration().org)
        except Exception:
            fabricante = "Desconhecido"

    # Determina tipo pelo fabricante ou portas
    tipo = "Desconhecido"
    fabricante_l = fabricante.lower()
    if fabricante_l.startswith(("siemens", "rockwell", "schneider", "mitsubishi")):
        tipo = "CLP"
    elif any(p in portas for p in (5000, 5357)):
        tipo = "Computador"
    elif 22 in portas:
        tipo = "Servidor ou Dispositivo IoT"
    elif 80 in portas or 443 in portas:
        tipo = "Smartphone / Tablet / Web Device"
    elif 554 in portas or 8554 in portas:
        tipo = "Câmera IP"

    nome = f"{tipo}_{ip}" if tipo != "Desconhecido" else f"Desconhecido_{ip}"

    dispositivo = {
        "ip": ip,
        "mac": mac or "",
        "subnet": subnet,
        "nome": nome,
        "tipo": tipo,
        "grupo": grupo,
        "metadata": {
            "fabricante": fabricante,
            "modelo": "Desconhecido",
            "versao_firmware": "N/A",
            "data_instalacao": None,
            "responsavel": "",
            "numero_serie": ""
        },
        "tags": [],
        "status": "Offline",
        "portas": sorted(list(set(portas))),
        "data_registro": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "logs": [
            {
                "acao": "Enriquecimento",
                "detalhes": f"Dispositivo identificado como {tipo}, fabricante: {fabricante}",
                "data": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }
        ]
    }

    # Salva no arquivo correto
    if tipo == "CLP":
        _clps_data.append(dispositivo)
        salvar_clps()
        logging.info(f"[INFO] Novo CLP criado e salvo em {CLPS_FILE}: {ip}")
    else:
        _others_data.append(dispositivo)
        salvar_others()
        logging.info(f"[INFO] Novo dispositivo (não-CLP) criado e salvo em {DEVICES_FILE}: {ip}")

    return dispositivo





def conectar(clp: dict, port: int = None, timeout: float = 3.0) -> bool:
    """Tenta conectar ao CLP via Modbus e atualiza o dicionário."""
    ip = clp["IP"]
    p = port or (clp["PORTAS"][0] if clp["PORTAS"] else 502)
    try:
        client = ModbusTcpClient(host=ip, port=int(p), timeout=timeout)
        ok = client.connect()
        clp["conectado"] = bool(ok)
        if ok:
            _active_clients[ip] = client
        status = 'Conectado' if ok else 'Falha ao conectar'
        adicionar_log(clp, f"{status} usando a porta {p}.")
        return clp["conectado"]
    except Exception as e:
        clp["conectado"] = False
        adicionar_log(clp, f"Exceção ao conectar na porta {p}: {e}")
        return False

def desconectar(clp: dict):
    """Desconecta do CLP."""
    ip = clp["IP"]
    client = _active_clients.get(ip)
    if client and client.is_socket_open():
        client.close()
        if ip in _active_clients:
            del _active_clients[ip]
    clp["conectado"] = False
    adicionar_log(clp, "Conexão encerrada.")

def get_client(ip: str):
    """Obtém o objeto de cliente Modbus ativo para um determinado IP."""
    return _active_clients.get(ip)

def adicionar_porta(clp: dict, porta: int):
    """Adiciona uma nova porta à lista do CLP."""
    porta = int(porta)
    if porta not in clp["PORTAS"]:
        clp["PORTAS"].append(porta)
        adicionar_log(clp, f"Porta {porta} adicionada à lista de portas conhecidas.")

def adicionar_log(clp: dict, texto: str):
    """Adiciona uma entrada de log ao CLP."""
    if "logs" not in clp:
        clp["logs"] = []
    clp["logs"].append(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - {texto}")

def get_info(clp: dict) -> dict:
    """Retorna um dicionário serializável com as informações do CLP."""
    # Garante que o status está atualizado
    clp["status"] = "Online" if clp.get("conectado") else "Offline"
    
    # --- CORREÇÃO APLICADA AQUI ---
    # Padroniza as chaves para corresponderem às da função 'criar_clp'
    return {
        "ip": clp.get("ip"),  # Chave corrigida de "ip" para "IP"
        "unidade": clp.get("unidade"),
        "portas": clp.get("portas", []), # Chave corrigida de "portas" para "PORTAS"
        "conectado": clp.get("conectado", False),
        "data_registro": clp.get("data_registro"),
        "nome": clp.get("nome"),
        "descricao": clp.get("descricao"),
        "logs": clp.get("logs", []),
        "status": clp.get("status"), # Adicionamos o status aqui também
        "tags": clp.get("tags", []),
    }



def listar_clps() -> List[dict]:
    """Retorna uma lista contendo os CLPs cadastrados (dicionários inteiros)."""
    return _clps_data




================================================================================
Arquivo: discovery.py
Pasta: utils\discovery.py
--------------------------------------------------------------------------------
import ipaddress
import json
from scapy.all import sniff, srp, Ether, ARP, IP, conf
from .portas import escanear_portas

# [DEBUG] Aumenta o nível de verbosidade do Scapy para nos dar mais informações se necessário
# conf.verb = 1 

def _discover_subnets_passively(timeout=60):
    """Escuta passivamente o tráfego da rede."""
    print(f"[*] Fase 1: Ouvindo passivamente o tráfego da rede por {timeout} segundos...")
    discovered_ips = set()

    def packet_handler(packet):
        if packet.haslayer(ARP):
            ip_src = packet[ARP].psrc
            # [DEBUG] Informa qual IP foi visto em um pacote ARP
            print(f"    [DEBUG] ARP visto do IP: {ip_src}")
            discovered_ips.add(ip_src)
        elif packet.haslayer(IP):
            ip_src = packet[IP].src
            # [DEBUG] Informa qual IP foi visto em um pacote IP
            print(f"    [DEBUG] Pacote IP visto do IP: {ip_src}")
            discovered_ips.add(ip_src)
    
    sniff(prn=packet_handler, store=0, timeout=timeout)

    # [DEBUG] Mostra todos os IPs únicos que foram capturados antes de processá-los
    print(f"\n[DEBUG] Total de {len(discovered_ips)} IPs únicos capturados passivamente: {list(discovered_ips)}")

    if not discovered_ips:
        return []
    
    subnets = set()
    print("[DEBUG] Processando IPs para determinar sub-redes (/24)...")
    for ip in discovered_ips:
        try:
            ip_obj = ipaddress.ip_address(ip)
            if not ip_obj.is_loopback and not ip_obj.is_multicast and not ip_obj.is_private:
                # [DEBUG] Informa sobre IPs públicos ou incomuns que foram ignorados (ajuste se necessário)
                print(f"    [DEBUG] Ignorando IP não privado/loopback/multicast: {ip}")
                continue
                
            network = ipaddress.ip_network(f"{ip}/24", strict=False)
            # [DEBUG] Mostra como cada IP foi mapeado para uma sub-rede
            print(f"    [DEBUG] IP '{ip}' mapeado para a sub-rede '{network}'")
            subnets.add(str(network))
        except ValueError:
            # [DEBUG] Informa se algum valor capturado não é um IP válido
            print(f"    [DEBUG] Valor inválido '{ip}' ignorado.")
            continue
            
    print(f"\n[+] Sub-redes ativas detectadas: {list(subnets)}")
    return list(subnets)

def _scan_arp_on_subnet(network_range, timeout=3):
    """
    Executa um ARP scan e retorna uma lista de dicionários,
    cada um contendo ip, mac e a sub-rede.
    """
    print(f"\n[*] Fase 2: Varrendo ativamente a sub-rede {network_range}...")
    clients_list = []
    try:
        # [DEBUG] Mostra o pacote exato que será enviado à rede
        arp_request = ARP(pdst=network_range)
        broadcast = Ether(dst="ff:ff:ff:ff:ff:ff")
        arp_request_broadcast = broadcast / arp_request
        print(f"    [DEBUG] Enviando pacote ARP para a sub-rede: {network_range}")
        
        answered_list, unanswered_list = srp(arp_request_broadcast, timeout=timeout, verbose=0)

        # [DEBUG] Informa quantos pacotes receberam resposta e quantos não
        print(f"    [DEBUG] Recebidas {len(answered_list)} respostas e {len(unanswered_list)} não respostas.")

        if not answered_list:
            print(f"[!] Nenhum dispositivo respondeu na sub-rede {network_range}.")
            return []

        for sent_packet, received_packet in answered_list:
            client_info = {
                "ip": received_packet.psrc,
                "mac": received_packet.hwsrc,
                "subnet": network_range
            }
            # [DEBUG] Mostra cada dispositivo encontrado em tempo real
            print(f"    [DEBUG] Encontrado: IP={client_info['ip']}, MAC={client_info['mac']}")
            clients_list.append(client_info)
        
        print(f"[+] Encontrados {len(clients_list)} dispositivos em {network_range}.")
        return clients_list
        
    except Exception as e:
        print(f"[!] Erro durante o scan em {network_range}: {e}")
        return []

def save_discoveries_to_json(devices_list, filename="data/discovery_results.json"):
    """Salva a lista de dispositivos descobertos em um arquivo JSON."""
    if not devices_list:
        print("\n[!] Nenhum dispositivo para salvar no arquivo JSON.")
        return

    try:
        # [DEBUG] Mostra quantos dispositivos serão salvos
        print(f"\n[DEBUG] Preparando para salvar {len(devices_list)} dispositivos no arquivo '{filename}'...")
        # Ordena a lista de dicionários pela chave 'ip'
        sorted_list = sorted(devices_list, key=lambda x: ipaddress.ip_address(x['ip']))
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(sorted_list, f, indent=4, ensure_ascii=False)
        print(f"\n[*] Relatório de descoberta completo salvo em '{filename}'")
    except Exception as e:
        print(f"[!] Erro ao salvar o arquivo JSON: {e}")


def run_full_discovery(passive_timeout=60):
    """
    Orquestra a descoberta e retorna uma lista de dicionários
    com os dispositivos encontrados.
    """
    try:
        target_subnets = _discover_subnets_passively(timeout=passive_timeout)
        if not target_subnets:
            print("\n[!] Não foi possível descobrir sub-redes ativas.")
            return []

        print("\n" + "="*50)
        print("[*] INICIANDO FASE DE VARREDURA ATIVA")
        print("="*50)
        all_found_devices = {} 
        for subnet in target_subnets:
            found_clients_on_subnet = _scan_arp_on_subnet(subnet)
            for client in found_clients_on_subnet:
                if client['ip'] not in all_found_devices:
                    # [DEBUG] Informa sobre um novo dispositivo adicionado à lista final
                    print(f"    [DEBUG] Adicionando novo dispositivo à lista final: {client['ip']}")
                    print("\n[*] Iniciando escaneamento de portas")
                    portas = escanear_portas(client['ip'])
                    all_found_devices[client['ip']] = client
                    client["portas"] = portas
                else:
                    # [DEBUG] Informa se um dispositivo foi visto novamente (em outra sub-rede, por exemplo)
                    print(f"    [DEBUG] Dispositivo {client['ip']} já estava na lista. Atualizando informações.")
                    all_found_devices[client['ip']] = client # Atualiza caso haja alguma info nova
                    client["portas"] = portas
        
        print("\n[*] Descoberta de IPs concluída.")
        # [DEBUG] Mostra um resumo final dos IPs únicos encontrados
        final_ips = list(all_found_devices.keys())
        final_ips.sort(key=ipaddress.ip_address)
        print(f"[DEBUG] Total de {len(final_ips)} dispositivos únicos encontrados em todas as sub-redes: {final_ips}")
        
        return list(all_found_devices.values())

    except PermissionError:
        print("\n[ERRO FATAL] A descoberta completa precisa ser executada com privilégios de administrador/root.")
        return None
    except KeyboardInterrupt:
        print("\n[!] Processo interrompido pelo usuário.")
        return None
    except Exception as e:
        print(f"\n[ERRO INESPERADO NA DESCOBERTA] {e}")
        return None

# Bloco de execução principal
if __name__ == "__main__":
    print("--- INICIANDO SCRIPT DE DESCOBERTA DE REDE ---")
    # Aumente o passive_timeout se sua rede for muito "quieta"
    discovered_devices = run_full_discovery(passive_timeout=60)
    
    if discovered_devices is not None:
        save_discoveries_to_json(discovered_devices)
    else:
        print("\n--- SCRIPT ENCERRADO COM ERRO ---")
        
    print("\n--- EXECUÇÃO FINALIZADA ---")


================================================================================
Arquivo: network.py
Pasta: utils\network.py
--------------------------------------------------------------------------------
import ipaddress

def get_subnet_from_ip(ip : str) -> str:
    """ Recebe um IP e retorna sua subrede

    Args:
        ip (str): _description_

    Returns:
        str: Rede_X.Y.Z.0-24
    """
    try:
        #Cria um objeto de endereço IP
        ip_obj : ipaddress.IPv4Address | ipaddress.IPv6Address
        ip_obj = ipaddress.ip_address(ip)

        #ignora IPs de loopback (localhost)
        if ip_obj.is_loopback:
            return None
        
        #Calcula a rede com máscara /24 
        rede = ipaddress.ip_network(f"{ip}/24", strict=False)

        #Formata o nome do grupo
        return f"Rede_{rede.network_address}-{rede.prefixlen}"
    
    except ValueError:
        #retorna None se a string do IP foor inválida
        return None
    
    except Exception as e:
        return None


================================================================================
Arquivo: portas.py
Pasta: utils\portas.py
--------------------------------------------------------------------------------
import subprocess
import re
import shutil


try:
    from scapy.all import sr1, IP, TCP, conf
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False

def _parse_nmap_output(output: str) -> list[int]:
    """Extrai portas abertas do output do nmap (lista de ints)."""
    portas_abertas = re.findall(r'(\d+)/tcp\s+open', output)
    return sorted({int(p) for p in portas_abertas})

def _scapy_syn_check(ip: str, ports, timeout=1) -> list[int]:
    """Fallback com Scapy: envia SYN e espera SYN-ACK. Retorna lista de portas abertas."""
    if not SCAPY_AVAILABLE:
        print("Scapy não disponível para fallback.")
        return []

    conf.verb = 0
    abertas = []
    for p in ports:
        try:
            pkt = IP(dst=ip)/TCP(dport=int(p), flags="S")
            resp = sr1(pkt, timeout=timeout, verbose=False)
            # Se a resposta for um pacote TCP com a flag SYN-ACK (0x12), a porta está aberta.
            if resp and resp.haslayer(TCP) and resp[TCP].flags & 0x12:
                abertas.append(int(p))
        except Exception as e:
            print(f"Erro no scapy-syn check para {ip}:{p} -> {e}")
    return sorted(set(abertas))






def escanear_portas(ip: str, intervalo: int = 1000, timeout: int = 60, portas_alvo: list = None) -> list[int]:
    """
    Escaneia portas abertas via nmap (ou fallback Scapy) e RETORNA uma lista de portas.
    """
    print(f"Iniciando escaneamento de portas para o IP: {ip}...")

    ports_to_check_str = ""
    if portas_alvo:
        ports_to_check_str = ",".join(map(str, sorted({int(p) for p in portas_alvo})))
    else:
        ports_to_check_str = f"1-{int(intervalo)}"

    portas_encontradas = []
    nmap_path = shutil.which("nmap")

    if nmap_path:
        cmd = [nmap_path, '-sT', '-n', '-T4', '-p', ports_to_check_str, ip]
        try:
            print(f"Executando nmap: {' '.join(cmd)}")
            proc = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout, check=False)
            if proc.returncode == 0:
                portas_encontradas = _parse_nmap_output(proc.stdout)
            else:
                print(f"Nmap retornou código {proc.returncode} para {ip}. stderr: {proc.stderr}")
        except subprocess.TimeoutExpired:
            print(f"Nmap expirou (timeout) ao escanear {ip}")
        except Exception as e:
            print(f"Erro inesperado ao executar nmap para {ip}: {e}")

    # Se nmap falhou ou não encontrou nada, tenta o fallback com Scapy se portas específicas foram dadas
    if not portas_encontradas and portas_alvo:
        print(f"Nmap não encontrou portas em {ip}. Tentando fallback com Scapy para {portas_alvo}.")
        portas_encontradas = _scapy_syn_check(ip, portas_alvo)
    
    if portas_encontradas:
        print(f"SUCESSO: Portas abertas encontradas em {ip}: {portas_encontradas}")
    else:
        print(f"Nenhuma porta aberta encontrada em {ip} com os métodos utilizados.")
        
    return portas_encontradas


================================================================================
Arquivo: root.py
Pasta: utils\root.py
--------------------------------------------------------------------------------

import sys
import os

# --- NOVO: LÓGICA PARA DEFINIR O DIRETÓRIO RAIZ DO PROJETO ---
def get_project_root():
    """
    Retorna o caminho raiz do projeto, funcionando tanto em modo de
    desenvolvimento (.py) quanto em modo de produção (.exe).
    """
    if hasattr(sys, '_MEIPASS'):
        # Estamos rodando em um executável criado pelo PyInstaller
        # _MEIPASS é o caminho para a pasta temporária onde tudo foi extraído
        return sys._MEIPASS
    else:
        # Estamos rodando como um script normal.
        # __file__ está em /utils/clp_manager.py, então subimos dois níveis
        # para chegar na raiz do projeto.
        return os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


================================================================================
Arquivo: tags_manager.py
Pasta: utils\tags_manager.py
--------------------------------------------------------------------------------
# utils/tags_manager.py
import json
import os
from utils.root import get_project_root

PROJECT_ROOT = get_project_root()
TAGS_FILE = os.path.join(PROJECT_ROOT, "data/tags.json")

def _carregar_tags():
    if not os.path.exists(TAGS_FILE):
        return []
    try:
        with open(TAGS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return []

def _salvar_tags(tags):
    with open(TAGS_FILE, "w", encoding="utf-8") as f:
        json.dump(tags, f, indent=4, ensure_ascii=False)

tags_globais = _carregar_tags()

def adicionar_tag_global(tag):
    if tag not in tags_globais:
        tags_globais.append(tag)
        _salvar_tags(tags_globais)
        return True
    return False


================================================================================
Arquivo: __init__.py
Pasta: utils\__init__.py
--------------------------------------------------------------------------------



